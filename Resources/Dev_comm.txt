	1. При выборе файла определяем, является ли он elf (начало файла - бинарная последовательность - 7F 45 4C 46 - ELF).
Обычно в контейнере 5 вхождений elf.
	2. Разбираем шапки всех эльфов.
Class (32/64): 5 байт
Data (Little/Big): 6 байт
Старт программных заголовков: 4(8) байт, сдвиг 22(26)
Размер заголовков: 2 байта, сдвиг 10(14)
Количество заголовков: 2 байта

Итого шапка+заголовки = 0х74, которые пропускаем. Аналог нуля далее.
Адрес первой программы 0х38-4-0х74
Размер 0х48-4-0х20000
Адрес второй программы 0х58-4-0х20074
Размер 0х68-4-0х280
Конец файла 0х202F4
	3. Разбираем шапку первого эльфа.

Итого шапка+заголовки = 0х1D4 первая нулевая программа
Адрес последней программы 0х34+0х20*12+4 = 0х1B8-4-0х32000
Размер не равный нулю 0х1C8-4-0х2CA0
Конец файла 0х34CA0
	4. Разбираем шапку второго эльфа.

Итого шапка+заголовки = 0х238 первая нулевая программа
Адрес последней программы 0х40+0х38*8+8 = 0х208-8-0хD0000
Размер не равный нулю 0х220-8-0х2BE0
Конец файла 0xD2BE0
	5. Разбираем шапку третьего эльфа.

Итого шапка+заголовки = 0х1C8 первая нулевая программа
Адрес последней программы 0х40+0х38*6+8 = 0х198-8-0х5B000
Размер не равный нулю 0х1B0-8-0хFF8
Конец файла 0x5BFF8
	6. Разбираем шапку четвёртого эльфа.

Итого шапка+заголовки = 0х1C8 первая нулевая программа
Адрес последней программы 0х40+0х38*6+8 = 0х198-8-0х1E000
Размер не равный нулю 0х1B0-8-0хFF8
Конец файла 0x1EFF8
	10. По маске "D00DFEED" находим вхождение в device tree
Первый адрес 0xCAB0 (это четвёртая программа из шапки), длина 0x361C(13852)
Само дерево 0x3619(13849)
	11. Копируем device tree blob
dd bs=1 count=13849 skip=51888 if=5.elf of=5.dtb
	12. Преобразовываем в текст
dtc -O dts -o 5.dts 5.dtb
	13. Находим во втором эльфе список доступных процессоров. Пока по маске SM_KAILUA.
Это четвёртая программа, начинается с адреса 0х94000 и размером 0х10000
По адресу 0х96210 начинается список доступных процессоров (1+24):
UNKNOWN
SM_KAILUA - Snapdragon 8 Gen 1
SMP_KAILUA - Snapdragon 8 Gen 1 (модифицированная версия)
SXR_AURORA - Snapdragon 7c
QRU_LASSEN - Snapdragon 8 Gen 2
QDU_LASSEN - Snapdragon 8 Gen 2 (модифицированная версия)
QDU1010_LASSEN - Snapdragon 8 Gen 2 (модифицированная версия)
QRU1032_LASSEN - Snapdragon 8 Gen 2 (модифицированная версия)
QRU1052_LASSEN - Snapdragon 8 Gen 2 (модифицированная версия)
QRU1062_LASSEN - Snapdragon 8 Gen 2 (модифицированная версия)
SXR_HALLIDAY - Snapdragon 7c Gen 2
SM_LANAI - Snapdragon 7 Gen 1
SMP_LANAI - Snapdragon 7 Gen 1 (модифицированная версия)
SCP_HAMOA - Snapdragon 6 Gen 1
SDX_PINNACLES - Snapdragon X55
SDX_PINNACLES_M - Snapdragon X55 (модифицированная версия)
SA_PINNACLES - Snapdragon X55 (модифицированная версия)
SA_PINNACLES_L - Snapdragon X55 (модифицированная версия)
SSG_AURORA - Snapdragon 7c
SM_KAPITI - Snapdragon 8 Gen 1 (модифицированная версия)
SDX_KUNO_SINGLEDIE - Snapdragon X60
SDX_KUNO_HYBRID - Snapdragon X60 (гибридная версия)
SSG2_AURORA - Snapdragon 7c Gen 2
SG_KAILUA - Snapdragon 8 Gen 1
SGP_KAILUA - Snapdragon 8 Gen 1 (модифицированная версия)
	14. Для поиска команд! По адресу 0x9422B в том же файле и той же программе лежат JTAG ID и OEM ID и Serial Number. Нужно найти какими запросами к ним подтягиваются данные!
Проверить в исходниках формирование команды Sahara С01, 02, 03, 07. Вполне вероятно, что идёт запрос через peek к QFuses процессора по фиксированным адресам. Для Sahara v3 могли либо изменить адреса, либо размер, либо и то и другое - из-за этого и не отрабатывают стандартные команды!
	15. Находим таблицу хешей и по ней проверяем целостность данных программера.
Для второго эльфа таблица хешей лежит в последней (9) программе (старт 0хD0000, размер 0x2BE0).
п1 - 0xD0200 - 0x30 (хеш шапки)
п2 - 230(все нули)
п3 - 260
п4 - 0xD0290 = 0x30(все нули)
п5 - 0хD02C0 - 0x30(48 байт-96 знаков)
п6 - 2F0
п7 - 320(все нули)
п8 - 350(все нули)
п9 - 0xD0380 - 0x30(все нули) - тут таблица хешей - до 0xD03B0
	16. Что-то непонятное (104 байта, 0x68) с 0xD03B0 до начала сертификатов (0xD0418)
	17. Вероятно, версия программера (7) переехала по адресу 0xD0004